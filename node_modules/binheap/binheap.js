// Generated by CoffeeScript 1.10.0

/*

  Tyler Anderson 2011-2015
 */

(function() {
  var BinaryHeap;

  BinaryHeap = (function() {
    function BinaryHeap(score_func) {
      this.heap = [];
      this.scoreFunction = score_func;
    }

    BinaryHeap.prototype.push = function(element) {
      this.heap.push(element);
      this.sinkDown(this.heap.length - 1);
      return true;
    };

    BinaryHeap.prototype.pop = function() {
      var end, result;
      result = this.heap[0];
      end = this.heap.pop();
      if (this.heap.length > 0) {
        this.heap[0] = end;
        this.bubbleUp(0);
      }
      return result;
    };

    BinaryHeap.prototype.remove = function(node) {
      var end, i;
      i = this.heap.indexOf(node);
      end = this.heap.pop();
      if (i !== this.heap.length - 1) {
        this.heap[i] = end;
        if (this.scoreFunction(end) < this.scoreFunction(node)) {
          this.sinkDown(i);
        } else {
          this.bubbleUp(i);
        }
      }
      return true;
    };

    BinaryHeap.prototype.size = function() {
      return this.heap.length;
    };

    BinaryHeap.prototype.rescoreElement = function(node) {
      return this.sinkDown(this.heap.indexOf(node));
    };

    BinaryHeap.prototype.sinkDown = function(n) {
      var element, parent, parentN;
      element = this.heap[n];
      while (n > 0) {
        parentN = ((n + 1) >> 1) - 1;
        parent = this.heap[parentN];
        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.heap[parentN] = element;
          this.heap[n] = parent;
          n = parentN;
          true;
        } else {
          break;
        }
      }
      return true;
    };

    BinaryHeap.prototype.bubbleUp = function(n) {
      var child1, child1N, child1Score, child2, child2N, child2Score, elemScore, element, length, swap;
      length = this.heap.length;
      element = this.heap[n];
      elemScore = this.scoreFunction(element);
      while (true) {
        child2N = (n + 1) << 1;
        child1N = child2N - 1;
        swap = null;
        if (child1N < length) {
          child1 = this.heap[child1N];
          child1Score = this.scoreFunction(child1);
          if (child1Score < elemScore) {
            swap = child1N;
          }
        }
        if (child2N < length) {
          child2 = this.heap[child2N];
          child2Score = this.scoreFunction(child2);
          if (child2Score < (swap === null ? elemScore : child1Score)) {
            swap = child2N;
          }
        }
        if (swap !== null) {
          this.heap[n] = this.heap[swap];
          this.heap[swap] = element;
          n = swap;
          true;
        } else {
          break;
        }
      }
      return true;
    };

    return BinaryHeap;

  })();

  module.exports = function(score_function) {
    return new BinaryHeap(score_function);
  };

}).call(this);
